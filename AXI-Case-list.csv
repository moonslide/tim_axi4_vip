TC 編號,測試名稱 (Test Name),注入訊號 (AXI4 Signal),注入值/條件,注入時機 (AXI4 Phase/Condition),驗證點/目的,完成度,,,,,預期行為 (Master/Slave Response) 
1. 基本寫入操作 (Basic Write Operations),,,,,,,,,,,
TC_001,TC_Single_Write_OKAY,"AWVALID, AWADDR, AWLEN, AWSIZE, AWBURST, AWID, WVALID, WDATA, WSTRB, WLAST, WID","AWID=0x1, AWADDR=0x1000, AWLEN=0x0 (1 beat), AWSIZE=0b010 (4 bytes), AWBURST=0b01 (INCR)。&lt;br>WID=0x1, WDATA=0xDEADBEEF, WSTRB=0xF, WLAST=1。",Master 依序發出 AW Channel 和 W Channel 訊號,驗證 Slave 能正確接收單筆寫入請求，並回覆 OKAY。資料正確寫入指定位址。,,,,,,"Master 行為:&lt;br>1. t0: AWVALID=1, AWID=0x1, AWADDR=0x1000, etc.&lt;br>2. t0: WVALID=1, WID=0x1, WDATA=0xDEADBEEF, WSTRB=0xF, WLAST=1.&lt;br>Slave 行為:&lt;br>1. AWREADY 在 AWVALID 後 0-N clks 拉高 (假設 t1)。&lt;br>2. WREADY 在 WVALID 後 0-N clks 拉高 (假設 t2)。&lt;br>3. 交易完成後 (AWVALID&AWREADY 和 WVALID&WREADY&WLAST 都發生後)，Slave 在 0-M clks 後拉高 BVALID=1，並提供 BID=0x1, BRESP=0b00 (OKAY) (假設 t3)。&lt;br>Master 驗證:&lt;br>1. 收到 BVALID=1, BID=0x1, BRESP=0b00。&lt;br>監控器驗證:&lt;br>1. 0x1000 處的記憶體內容被更新為 0xDEADBEEF。&lt;br>2. 所有 AXI channel handshake 符合協定。"
TC_002,TC_Single_Write_Min_AWSIZE,"AWVALID, AWADDR, AWLEN, AWSIZE, AWBURST, AWID, WVALID, WDATA, WSTRB, WLAST, WID","AWID=0x1, AWADDR=0x1004, AWLEN=0x0, AWSIZE=0b000 (1 byte), AWBURST=0b01 (INCR)。&lt;br>WID=0x1, WDATA=0xAB (or 0xXXAB with WSTRB=0x1) , WSTRB=0x1 (byte 0), WLAST=1。",Master 依序發出 AW Channel 和 W Channel 訊號,驗證 Slave 使用最小傳輸粒度時的單筆寫入。,,,,,,"Slave 行為: AWREADY=1, WREADY=1。之後 BVALID=1, BID=0x1, BRESP=0b00 (OKAY)。&lt;br>監控器驗證: 位址 0x1004 的 byte 0 被更新為 0xAB。其他 bytes in 0x1004 (if wider register) 不變 (或依 DUT spec)。"
TC_003,TC_Single_Write_Max_AWSIZE,"AWVALID, AWADDR, AWLEN, AWSIZE, AWBURST, AWID, WVALID, WDATA, WSTRB, WLAST, WID","AWID=0x1, AWADDR=0x1008, AWLEN=0x0, AWSIZE=0b010 (4 bytes), AWBURST=0b01 (INCR)。&lt;br>WID=0x1, WDATA=0x12345678, WSTRB=0xF, WLAST=1。",Master 依序發出 AW Channel 和 W Channel 訊號,驗證 Slave 使用最大傳輸粒度時的單筆寫入。,,,,,,"Slave 行為: AWREADY=1, WREADY=1。之後 BVALID=1, BID=0x1, BRESP=0b00 (OKAY)。&lt;br>監控器驗證: 位址 0x1008 的內容被更新為 0x12345678。"
TC_004,TC_Burst_Write_INCR_OKAY,"AWVALID, AWADDR, AWLEN, AWSIZE, AWBURST, AWID, WVALID, WDATA, WSTRB, WLAST, WID","AWID=0x2, AWADDR=0x1010, AWLEN=0x3 (4 beats), AWSIZE=0b010 (4 bytes), AWBURST=0b01 (INCR)。&lt;br>Beat 1: WID=0x2, WDATA=0xCAFE0000, WSTRB=0xF, WLAST=0 @ 0x1010&lt;br>Beat 2: WID=0x2, WDATA=0xCAFE0001, WSTRB=0xF, WLAST=0 @ 0x1014&lt;br>Beat 3: WID=0x2, WDATA=0xCAFE0002, WSTRB=0xF, WLAST=0 @ 0x1018&lt;br>Beat 4: WID=0x2, WDATA=0xCAFE0003, WSTRB=0xF, WLAST=1 @ 0x101C",Master 依序發出 AW Channel 和 W Channel (4 beats) 訊號,驗證 Slave 能正確處理 INCR burst 寫入，資料依序寫入遞增位址。,,,,,,"Slave 行為:&lt;br>1. AWREADY=1 回應 AWVALID。&lt;br>2. 對於每個 WDATA beat，WREADY=1 回應 WVALID。&lt;br>3. 所有 beats 完成後，BVALID=1, BID=0x2, BRESP=0b00 (OKAY)。&lt;br>Master 驗證:&lt;br>1. 收到 BVALID=1, BID=0x2, BRESP=0b00。&lt;br>監控器驗證:&lt;br>1. 位址 0x1010 寫入 0xCAFE0000。&lt;br>2. 位址 0x1014 寫入 0xCAFE0001。&lt;br>3. 位址 0x1018 寫入 0xCAFE0002。&lt;br>4. 位址 0x101C 寫入 0xCAFE0003。"
TC_005,TC_Burst_Write_FIXED_OKAY,"AWVALID, AWADDR, AWLEN, AWSIZE, AWBURST, AWID, WVALID, WDATA, WSTRB, WLAST, WID","AWID=0x2, AWADDR=0x1020, AWLEN=0x1 (2 beats), AWSIZE=0b001 (2 bytes), AWBURST=0b00 (FIXED)。&lt;br>Beat 1: WID=0x2, WDATA=0xABBA, WSTRB=0x3, WLAST=0 @ 0x1020&lt;br>Beat 2: WID=0x2, WDATA=0xCDDC, WSTRB=0x3, WLAST=1 @ 0x1020",Master 依序發出 AW Channel 和 W Channel (2 beats) 訊號,驗證 Slave 能正確處理 FIXED burst 寫入，所有資料寫入相同位址。,,,,,,"Slave 行為: AWREADY=1。對每個 beat WREADY=1。完成後 BVALID=1, BID=0x2, BRESP=0b00 (OKAY)。&lt;br>監控器驗證: 位址 0x1020 的前 2 bytes 最終為 0xCDDC (或依 Slave 如何處理 동일位址重複寫入)。"
TC_006,TC_Burst_Write_WRAP_OKAY,"AWVALID, AWADDR, AWLEN, AWSIZE, AWBURST, AWID, WVALID, WDATA, WSTRB, WLAST, WID","AWID=0x2, AWADDR=0x103C, AWLEN=0x3 (4 beats), AWSIZE=0b010 (4 bytes), AWBURST=0b10 (WRAP)。Total size: 4*4=16 bytes.&lt;br>Beat 1: WDATA=D0 @ 0x103C (wrap boundary for 16-byte wrap is 0x1030-0x103F)&lt;br>Beat 2: WDATA=D1 @ 0x1030&lt;br>Beat 3: WDATA=D2 @ 0x1034&lt;br>Beat 4: WDATA=D3 (WLAST=1) @ 0x1038",Master 依序發出 AW Channel 和 W Channel (4 beats) 訊號,驗證 Slave 能正確處理 WRAP burst 寫入，位址按 WRAP 規則變化。,,,,,,"Slave 行為: AWREADY=1。對每個 beat WREADY=1。完成後 BVALID=1, BID=0x2, BRESP=0b00 (OKAY)。&lt;br>監控器驗證: 資料 D0, D1, D2, D3 分別寫入 0x103C, 0x1030, 0x1034, 0x1038。"
TC_007,TC_Write_SLVERR,"AWVALID, AWADDR, AWLEN, AWSIZE, AWID, WVALID, WDATA, WSTRB, WLAST, WID","AWID=0x3, AWADDR=0x1F00 (預設的 SLVERR 觸發位址), AWLEN=0x0, AWSIZE=0b010, AWBURST=0b01 (INCR)。&lt;br>WID=0x3, WDATA=0xBADD0000, WSTRB=0xF, WLAST=1。",Master 發出寫入請求到特定會觸發 SLVERR 的位址,驗證 Slave 在遇到內部錯誤時能正確回覆 SLVERR。,,,,,,"Slave 行為:&lt;br>1. AWREADY=1 回應 AWVALID。&lt;br>2. WREADY=1 回應 WVALID (Slave 可能會接受資料但標記為錯誤，或不實際寫入)。&lt;br>3. BVALID=1, BID=0x3, BRESP=0b10 (SLVERR)。&lt;br>Master 驗證:&lt;br>1. 收到 BVALID=1, BID=0x3, BRESP=0b10。&lt;br>監控器驗證:&lt;br>1. 記憶體位址 0x1F00 的內容未被改變或為不可預期值 (依 DUT 設計)。&lt;br>2. BRESP 為 SLVERR。"
TC_008,TC_Write_DECERR,"AWVALID, AWADDR, AWLEN, AWSIZE, AWID","AWID=0x3, AWADDR=0x2000 (超出 Slave 的 0x1000-0x1FFF 範圍), AWLEN=0x0, AWSIZE=0b010, AWBURST=0b01 (INCR)。W Channel 的訊號可能不會發生或被忽略。",Master 發出寫入請求到 Slave 外部但定址到該 Slave 的無效位址,驗證 Slave (或其外圍 Interconnect) 在遇到無法解碼的位址時能正確回覆 DECERR。,,,,,,"Slave/Interconnect 行為:&lt;br>1. AWREADY=1 (Interconnect 可能接受位址然後才發現無法解碼)。&lt;br>2. W Channel 相關訊號可能不被 Slave 理會。&lt;br>3. BVALID=1, BID=0x3, BRESP=0b11 (DECERR)。&lt;br>監控器驗證: BRESP 為 DECERR。"
2. 基本讀取操作 (Basic Read Operations),,,,,,,,,,,
TC_009,TC_Single_Read_OKAY,"ARVALID, ARADDR, ARLEN, ARSIZE, ARBURST, ARID","前置條件: 位址 0x1040 已預先寫入資料 0xFEEDFACE。&lt;br>ARID=0x4, ARADDR=0x1040, ARLEN=0x0 (1 beat), ARSIZE=0b010 (4 bytes), ARBURST=0b01 (INCR)。",Master 發出 AR Channel 訊號,驗證 Slave 能正確回覆單筆讀取請求，並回傳正確資料與 OKAY。,,,,,,"Slave 行為:&lt;br>1. ARREADY=1 回應 ARVALID。&lt;br>2. 之後，RVALID=1, RID=0x4, RDATA=0xFEEDFACE, RRESP=0b00 (OKAY), RLAST=1。&lt;br>Master 驗證:&lt;br>1. 收到 RVALID=1, RID=0x4, RDATA=0xFEEDFACE, RRESP=0b00, RLAST=1。&lt;br>監控器驗證:&lt;br>1. Handshake 符合協定，讀取資料 0xFEEDFACE 正確。"
TC_010,TC_Single_Read_Min_ARSIZE,"ARVALID, ARADDR, ARLEN, ARSIZE, ARBURST, ARID","前置條件: 位址 0x1044 的 byte 0 已寫入 0xBC。&lt;br>ARID=0x4, ARADDR=0x1044, ARLEN=0x0, ARSIZE=0b000 (1 byte), ARBURST=0b01 (INCR)。",Master 發出 AR Channel 訊號,驗證 Slave 使用最小傳輸粒度時的單筆讀取。,,,,,,"Slave 行為: ARREADY=1。之後 RVALID=1, RID=0x4, RDATA (低位元組為 0xBC), RRESP=0b00 (OKAY), RLAST=1。&lt;br>監控器驗證: RDATA 的最低位元組為 0xBC。"
TC_011,TC_Single_Read_Max_ARSIZE,"ARVALID, ARADDR, ARLEN, ARSIZE, ARBURST, ARID","前置條件: 位址 0x1048 已寫入 0x87654321。&lt;br>ARID=0x4, ARADDR=0x1048, ARLEN=0x0, ARSIZE=0b010 (4 bytes), ARBURST=0b01 (INCR)。",Master 發出 AR Channel 訊號,驗證 Slave 使用最大傳輸粒度時的單筆讀取。,,,,,,"Slave 行為: ARREADY=1。之後 RVALID=1, RID=0x4, RDATA=0x87654321, RRESP=0b00 (OKAY), RLAST=1。&lt;br>監控器驗證: RDATA 為 0x87654321。"
TC_012,TC_Burst_Read_INCR_OKAY,"ARVALID, ARADDR, ARLEN, ARSIZE, ARBURST, ARID","前置條件: &lt;br>0x1050= 0xFACE0000&lt;br>0x1054= 0xFACE0001&lt;br>0x1058= 0xFACE0002&lt;br>0x105C= 0xFACE0003&lt;br>ARID=0x5, ARADDR=0x1050, ARLEN=0x3 (4 beats), ARSIZE=0b010, ARBURST=0b01 (INCR)。",Master 發出 AR Channel 訊號,驗證 Slave 能正確處理 INCR burst 讀取，依序回傳遞增位址的資料。,,,,,,"Slave 行為:&lt;br>1. ARREADY=1 回應 ARVALID。&lt;br>2. Beat 1: RVALID=1, RID=0x5, RDATA=0xFACE0000, RRESP=0b00, RLAST=0。&lt;br>3. Beat 2: RVALID=1, RID=0x5, RDATA=0xFACE0001, RRESP=0b00, RLAST=0。&lt;br>4. Beat 3: RVALID=1, RID=0x5, RDATA=0xFACE0002, RRESP=0b00, RLAST=0。&lt;br>5. Beat 4: RVALID=1, RID=0x5, RDATA=0xFACE0003, RRESP=0b00, RLAST=1。&lt;br>Master 驗證:&lt;br>1. 依序收到 4 beats 的正確資料、RID、RRESP 和 RLAST。&lt;br>監控器驗證:&lt;br>1. 所有讀取資料和位址對應正確。"
TC_013,TC_Burst_Read_FIXED_OKAY,"ARVALID, ARADDR, ARLEN, ARSIZE, ARBURST, ARID","前置條件: 位址 0x1060 內容會依讀取次數變化 (e.g. FIFO) 或固定為特定值 (e.g. 0xFIXEDDAT)。&lt;br>ARID=0x5, ARADDR=0x1060, ARLEN=0x1 (2 beats), ARSIZE=0b010, ARBURST=0b00 (FIXED)。",Master 發出 AR Channel 訊號,驗證 Slave 能正確處理 FIXED burst 讀取，回傳相同位址的資料。,,,,,,"Slave 行為: ARREADY=1。之後 Beat 1: RVALID=1, RDATA=D0, RLAST=0。Beat 2: RVALID=1, RDATA=D1, RLAST=1。 (D0, D1 來自 0x1060)。&lt;br>監控器驗證: 讀取資料來自固定位址 0x1060。"
TC_014,TC_Burst_Read_WRAP_OKAY,"ARVALID, ARADDR, ARLEN, ARSIZE, ARBURST, ARID","前置條件: 0x107C=D0, 0x1070=D1, 0x1074=D2, 0x1078=D3。&lt;br>ARID=0x5, ARADDR=0x107C, ARLEN=0x3 (4 beats), ARSIZE=0b010, ARBURST=0b10 (WRAP)。",Master 發出 AR Channel 訊號,驗證 Slave 能正確處理 WRAP burst 讀取，位址按 WRAP 規則變化回傳資料。,,,,,,"Slave 行為: ARREADY=1。之後 Beat 1 (0x107C): RDATA=D0, RLAST=0。Beat 2 (0x1070): RDATA=D1, RLAST=0。Beat 3 (0x1074): RDATA=D2, RLAST=0。Beat 4 (0x1078): RDATA=D3, RLAST=1。&lt;br>監控器驗證: 讀取資料與 WRAP 位址順序匹配。"
TC_015,TC_Read_SLVERR,"ARVALID, ARADDR, ARLEN, ARSIZE, ARID","ARID=0x6, ARADDR=0x1F00 (SLVERR 觸發位址), ARLEN=0x0, ARSIZE=0b010。",Master 發出讀取請求到特定會觸發 SLVERR 的位址,驗證 Slave 在遇到內部錯誤時能正確回覆 SLVERR (在 R Channel)。,,,,,,"Slave 行為: ARREADY=1。之後 RVALID=1, RID=0x6, RDATA (don't care), RRESP=0b10 (SLVERR), RLAST=1。&lt;br>監控器驗證: RRESP 為 SLVERR。"
TC_016,TC_Read_DECERR,"ARVALID, ARADDR, ARLEN, ARSIZE, ARID","ARID=0x6, ARADDR=0x2000 (超出範圍位址), ARLEN=0x0, ARSIZE=0b010。",Master 發出讀取請求到 Slave 外部但定址到該 Slave 的無效位址,驗證 Slave (或其外圍 Interconnect) 在遇到無法解碼的位址時能正確回覆 DECERR。,,,,,,"Slave/Interconnect 行為: ARREADY=1。之後 RVALID=1, RID=0x6, RDATA (don't care), RRESP=0b11 (DECERR), RLAST=1。&lt;br>監控器驗證: RRESP 為 DECERR。"
3. 交握時序變化 (Handshake Timing Variations),,,,,,,,,,,
TC_017,TC_HS_AW_Slave_Ready_Delay,"AWVALID (Master), AWREADY (Slave), AWADDR, AWID, etc.","Master t0: AWVALID=1, AWADDR=0x1080, AWID=0x7, AWLEN=0, AWSIZE=0b010。 Slave 收到 AWVALID=1 後，保持 AWREADY=0 5 個 clock cycles，然後在 t0+5clk 時拉高 AWREADY=1。",AW Phase,驗證 Slave 可以延遲 AWREADY，Master 應保持 AW* 訊號穩定直到 AWREADY 被致能。0~6 cycle,,,,,,"Master 行為: t0 至 t0+4clk: 保持 AW* 訊號穩定。&lt;br>Slave 行為: t0 至 t0+4clk: AWREADY=0。 t0+5clk: AWREADY=1。&lt;br>監控器驗證: Master 在 AWREADY=0 期間保持 AW* 穩定。後續 W, B channel 正確完成交易。"
TC_018,TC_HS_W_Slave_Ready_Delay,"WVALID (Master), WREADY (Slave), WDATA, WSTRB, WLAST, WID","單筆寫入 (AWLEN=0)，AWADDR=0x1084, AWID=0x7。AWVALID&AWREADY 已完成。&lt;br>Master t0: WVALID=1, WDATA=0xDDDDCCCC, WSTRB=0xF, WLAST=1, WID=0x7。Slave 保持 WREADY=0 3 個 clock cycles，然後在 t0+3clk 時拉高 WREADY=1。",W Phase,驗證 Slave 可以延遲 WREADY，Master 應保持 W* 訊號穩定。,,,,,,Master 行為: t0 至 t0+2clk: 保持 W* 訊號穩定。&lt;br>Slave 行為: t0 至 t0+2clk: WREADY=0。 t0+3clk: WREADY=1。&lt;br>監控器驗證: Master 在 WREADY=0 期間保持 W* 穩定。後續 B channel 正確完成。
TC_019,TC_HS_B_Master_Ready_Delay,"BVALID (Slave), BREADY (Master), BRESP, BID","單筆寫入 (AWADDR=0x1088, AWID=0x7) 的 AW, W phase 已完成。&lt;br>Slave t0: BVALID=1, BRESP=0b00, BID=0x7。Master 保持 BREADY=0 4 個 clock cycles，然後在 t0+4clk 時拉高 BREADY=1。",B Phase,驗證 Slave 在 BVALID=1 時能保持 B* 訊號穩定，直到 Master 致能 BREADY。,,,,,,Slave 行為: t0 至 t0+3clk: 保持 B* 訊號穩定。&lt;br>Master 行為: t0 至 t0+3clk: BREADY=0。 t0+4clk: BREADY=1。&lt;br>監控器驗證: Slave 在 BREADY=0 期間保持 B* 穩定。回應正確傳輸。
TC_020,TC_HS_AR_Slave_Ready_Delay,"ARVALID (Master), ARREADY (Slave), ARADDR, ARID, etc.","Master t0: ARVALID=1, ARADDR=0x108C, ARID=0x8, ARLEN=0。 Slave 保持 ARREADY=0 2 個 clock cycles，然後在 t0+2clk 時拉高 ARREADY=1。",AR Phase,驗證 Slave 可以延遲 ARREADY，Master 應保持 AR* 訊號穩定。,,,,,,Master 行為: t0 至 t0+1clk: 保持 AR* 訊號穩定。&lt;br>Slave 行為: t0 至 t0+1clk: ARREADY=0。 t0+2clk: ARREADY=1。&lt;br>監控器驗證: Master 在 ARREADY=0 期間保持 AR* 穩定。後續 R channel 正確完成。
TC_021,TC_HS_R_Master_Ready_Delay,"RVALID (Slave), RREADY (Master), RDATA, RRESP, RLAST, RID","單筆讀取 (ARADDR=0x1090, ARID=0x8) 的 AR phase 已完成。預期讀取資料 0xEEEEFFFF。&lt;br>Slave t0: RVALID=1, RDATA=0xEEEEFFFF, RRESP=0b00, RLAST=1, RID=0x8。Master 保持 RREADY=0 6 個 clock cycles，然後在 t0+6clk 時拉高 RREADY=1。",R Phase,驗證 Slave 在 RVALID=1 時能保持 R* 訊號穩定，直到 Master 致能 RREADY。,,,,,,Slave 行為: t0 至 t0+5clk: 保持 R* 訊號穩定。&lt;br>Master 行為: t0 至 t0+5clk: RREADY=0。 t0+6clk: RREADY=1。&lt;br>監控器驗證: Slave 在 RREADY=0 期間保持 R* 穩定。資料正確傳輸。
TC_022,TC_HS_AW_W_Channel_Separation,"AWVALID, AWREADY, WVALID, WREADY, AWADDR, WDATA, etc.","Case 1 (W data late):&lt;br>Master t0: AWVALID=1 (AWADDR=0x1094, AWID=0x9, AWLEN=0). Slave t1: AWREADY=1 (t1 >= t0)。&lt;br>Master t2 (t2 > t1+2clk): WVALID=1 (WDATA=0x12123434, WID=0x9, WLAST=1)。Slave t3: WREADY=1 (t3 >= t2)。&lt;br>Case 2 (W data early - 需多ID或Slave支援): 一般較少見，若Slave允許不同ID的WDATA先於AW，則類似，但通常測WID與AWID關聯。",AW and W Phases,驗證 Slave 能處理 AW 和 W channel 資訊在不同時間點到達的情況。,,,,,,"Slave 行為 (Case 1):&lt;br>1. t1: 接受 AW channel transaction。&lt;br>2. t3: 接受 W channel transaction。&lt;br>3. 之後發出 BVALID (BID=0x9, BRESP=OKAY)。&lt;br>監控器驗證: 資料 0x12123434 寫入 0x1094。交易順利完成。"
4. Burst 長度 (AxLEN) 邊界條件,,,,,,,,,,,
TC_023,TC_Boundary_Write_Max_Burst_Length,"AWVALID, AWADDR, AWLEN, AWSIZE, AWBURST, AWID, WVALID, WDATA, WSTRB, WLAST, WID","AWID=0xA, AWADDR=0x1100, AWLEN=0xFF (256 beats), AWSIZE=0b010 (4 bytes), AWBURST=0b01 (INCR)。&lt;br>Master 準備 256 個 WDATA beats，資料從 0xAABB0000 開始，每個 beat 資料+1。&lt;br>WLAST 在第 256 個 beat 時為 1。",AW & W Phase,驗證 Slave 是否支援 AXI4 規範的最大 burst 長度 (256 beats)。,,,,,,"Slave 行為:&lt;br>1. AWREADY=1 回應 AWVALID。&lt;br>2. 對所有 256 個 WDATA beats，WREADY=1 回應 WVALID。&lt;br>3. 第 256 個 beat 包含 WLAST=1。&lt;br>4. 所有 beats 完成後，BVALID=1, BID=0xA, BRESP=0b00 (OKAY)。&lt;br>監控器驗證:&lt;br>1. 從 0x1100 開始的 256 個連續 4-byte word (共 1KB) 被依序正確寫入 (e.g., 0x1100= 0xAABB0000, 0x1104= 0xAABB0001, ..., 0x14FC= 0xAABB00FF)。"
TC_024,TC_Boundary_Write_WRAP_Various_Lengths,"AWVALID, AWADDR, AWLEN, AWSIZE, AWBURST=WRAP, AWID, WVALID, WDATA","Test for AWLEN=0x3 (4 beats):&lt;br>AWID=0xA, AWADDR=0x1508, AWLEN=0x3, AWSIZE=0b010 (4 bytes), AWBURST=0b10 (WRAP)。&lt;br>Data: D0, D1, D2, D3. (Total burst size 16 bytes. Wrap boundary 0x1500-0x150F)&lt;br>Expected Addr Seq: 0x1508, 0x150C, 0x1500, 0x1504.",AW & W Phase,驗證 WRAP burst 支援的特定長度 (例如 4 beats)。,,,,,,"Slave 行為: AWREADY=1。對每個 WDATA beat WREADY=1。WLAST 在最後一個 beat (D3) 為 1。完成後 BVALID=1, BID=0xA, BRESP=0b00 (OKAY)。&lt;br>監控器驗證: 資料 D0, D1, D2, D3 分別寫入 0x1508, 0x150C, 0x1500, 0x1504。 (對其他 AWLEN 值重複此測試)。"
TC_025,TC_Boundary_Read_Max_Burst_Length,"ARVALID, ARADDR, ARLEN, ARSIZE, ARBURST=INCR, ARID","前置條件: 從 0x1600 至 0x19FC (1KB) 已預先寫入遞增資料 (e.g., 0xCCDD0000 至 0xCCDD00FF)。&lt;br>ARID=0xB, ARADDR=0x1600, ARLEN=0xFF (256 beats), ARSIZE=0b010, ARBURST=0b01 (INCR)。",AR Phase,驗證 Slave 是否支援 AXI4 規範的最大 burst 長度 (256 beats)。,,,,,,"Slave 行為: ARREADY=1。之後，Slave 依序送出 256 個 RDATA beats (RVALID=1, RRESP=0b00)，RID=0xB。第 256 個 RDATA beat 時 RLAST=1。&lt;br>監控器驗證: 從 0x1600 開始的 256 個 word 被正確讀出，與預寫入資料一致。"
5. 位址 (AxADDR) 邊界條件,,,,,,,,,,,
TC_026,TC_Boundary_Write_Addr_Lower,"AWVALID, AWADDR, AWLEN=0, AWSIZE=0b010, AWID=0x1, WVALID, WDATA=0x1000F1A5, WSTRB=0xF",AWADDR=0x1000 (Slave 支援的最低位址)。,AW Phase,驗證 Slave 對其位址空間下限的正確回應。,,,,,,"Slave 行為: AWREADY=1, WREADY=1。之後 BVALID=1, BID=0x1, BRESP=0b00 (OKAY)。&lt;br>監控器驗證: 資料 0x1000F1A5 寫入 0x1000。"
TC_027,TC_Boundary_Write_Addr_Upper,"AWVALID, AWADDR, AWLEN=0, AWSIZE=0b010, AWID=0x1, WVALID, WDATA=0x1FFCF1A5, WSTRB=0xF",AWADDR=0x1FFC (Slave 支援的最高有效 4-byte word 起始位址)。,AW Phase,驗證 Slave 對其位址空間上限的正確回應。,,,,,,"Slave 行為: AWREADY=1, WREADY=1。之後 BVALID=1, BID=0x1, BRESP=0b00 (OKAY)。&lt;br>監控器驗證: 資料 0x1FFCF1A5 寫入 0x1FFC。"
TC_028,TC_Boundary_Write_Addr_OutOfRange_DECERR,"AWVALID, AWADDR, AWLEN=0, AWSIZE=0b010, AWID=0x1",AWADDR=0x2000 (超出 Slave 的 0x1000-0x1FFF 範圍)。,AW Phase,驗證當位址在 Slave 內部未映射時，是否產生 DECERR (通常由 Interconnect 產生或 Slave 協助產生)。,,,,,,"Slave/Interconnect 行為: AWREADY=1。之後 BVALID=1, BID=0x1, BRESP=0b11 (DECERR)。&lt;br>監控器驗證: BRESP 為 DECERR。記憶體內容不變。"
TC_029,TC_Boundary_Write_Addr_Unaligned,"AWVALID, AWADDR, AWSIZE, AWLEN=0, AWID=0x1","AWADDR=0x1001, AWSIZE=0b010 (4 bytes)。 (4-byte 存取但位址未 4-byte 對齊)。",AW Phase,驗證 Slave 對未對齊位址的處理 (預期 SLVERR 或 DECERR，依 DUT 設計)。,,,,,,"Slave 行為 (假設不支援未對齊): AWREADY=1。之後 BVALID=1, BID=0x1, BRESP=0b10 (SLVERR) (或 0b11 (DECERR) 若由 interconnect 在更早階段判定)。&lt;br>監控器驗證: 收到預期的錯誤回應，記憶體內容未改變。"
TC_030,TC_Boundary_Write_INCR_Across_4KB,"AWVALID, AWADDR, AWLEN, AWSIZE=0b010, AWBURST=INCR, AWID=0x1",AWADDR=0x0FFC (假設 Slave 位址空間包含此區域，且 4KB 邊界為 0x0FFF-0x1000)。&lt;br>AWLEN=0x1 (2 beats)。&lt;br>Beat 1: WDATA=D0 @ 0x0FFC&lt;br>Beat 2: WDATA=D1 (WLAST=1) @ 0x1000,AW Phase,驗證 INCR burst 跨 4KB 邊界的行為 (AXI4 允許)。,,,,,,"Slave 行為: AWREADY=1。對每個 beat WREADY=1。完成後 BVALID=1, BID=0x1, BRESP=0b00 (OKAY)。&lt;br>監控器驗證: 資料 D0 寫入 0x0FFC，D1 寫入 0x1000。"
TC_031,TC_Boundary_Write_WRAP_Addr_Calculation,"AWVALID, AWADDR, AWLEN=0x3 (4 beats), AWSIZE=0b010, AWBURST=WRAP, AWID=0x1","AWADDR=0x100E (起始位址未對齊 burst size)。Total size = 4*4 = 16 bytes。Wrap boundary 0x1000-0x100F (for start addr 0x100E)。&lt;br>Expected Addr Seq: 0x100E, 0x1000, 0x1004, 0x1008 (WLAST on last)。Data D0-D3.",AW Phase,驗證 WRAP burst 的位址計算邏輯，特別是起始位址未對齊總 burst 大小的情況。,,,,,,"Slave 行為: AWREADY=1。對每個 beat WREADY=1。完成後 BVALID=1, BID=0x1, BRESP=0b00 (OKAY)。&lt;br>監控器驗證: 資料 D0-D3 依序寫入 0x100E, 0x1000, 0x1004, 0x1008。"
TC_032,TC_Boundary_Read_Addr_Lower,"ARVALID, ARADDR, ARLEN=0, ARSIZE=0b010, ARID=0x2",前置條件: 0x1000 已寫入 0xFACE1000。&lt;br>ARADDR=0x1000。,AR Phase,驗證 Slave 對其位址空間下限的正確讀取回應。,,,,,,"Slave 行為: ARREADY=1。之後 RVALID=1, RID=0x2, RDATA=0xFACE1000, RRESP=0b00, RLAST=1。&lt;br>監控器驗證: 讀取資料正確。"
TC_033,TC_Boundary_Read_Addr_Upper,"ARVALID, ARADDR, ARLEN=0, ARSIZE=0b010, ARID=0x2",前置條件: 0x1FFC 已寫入 0xFACE1FFC。&lt;br>ARADDR=0x1FFC。,AR Phase,驗證 Slave 對其位址空間上限的正確讀取回應。,,,,,,"Slave 行為: ARREADY=1。之後 RVALID=1, RID=0x2, RDATA=0xFACE1FFC, RRESP=0b00, RLAST=1。&lt;br>監控器驗證: 讀取資料正確。"
TC_034,TC_Boundary_Read_Addr_OutOfRange_DECERR,"ARVALID, ARADDR, ARLEN=0, ARSIZE=0b010, ARID=0x2",ARADDR=0x2000。,AR Phase,驗證當讀取位址在 Slave 內部未映射時，是否產生 DECERR。,,,,,,"Slave/Interconnect 行為: ARREADY=1。之後 RVALID=1, RID=0x2, RDATA(don't care), RRESP=0b11 (DECERR), RLAST=1。&lt;br>監控器驗證: RRESP 為 DECERR。"
TC_035,TC_Boundary_Read_Addr_Unaligned,"ARVALID, ARADDR, ARSIZE, ARLEN=0, ARID=0x2","ARADDR=0x1001, ARSIZE=0b010 (4 bytes)。",AR Phase,驗證 Slave 對未對齊讀取位址的處理。,,,,,,"Slave 行為 (假設不支援): ARREADY=1。之後 RVALID=1, RID=0x2, RDATA(don't care), RRESP=0b10 (SLVERR) 或 0b11 (DECERR), RLAST=1。&lt;br>監控器驗證: 收到預期的錯誤回應。"
TC_036,TC_Boundary_Read_INCR_Across_4KB,"ARVALID, ARADDR, ARLEN, ARSIZE=0b010, ARBURST=INCR, ARID=0x2","前置條件: 0x0FFC=D0, 0x1000=D1。&lt;br>ARADDR=0x0FFC (假設 Slave 位址空間包含此區域)。&lt;br>ARLEN=0x1 (2 beats)。",AR Phase,驗證 INCR burst 讀取跨 4KB 邊界的行為。,,,,,,"Slave 行為: ARREADY=1。之後 Beat 1: RDATA=D0, RLAST=0。Beat 2: RDATA=D1, RLAST=1。 RRESP 均為 OKAY, RID=0x2。&lt;br>監控器驗證: 正確讀出 D0 和 D1。"
TC_037,TC_Boundary_Read_WRAP_Addr_Calculation,"ARVALID, ARADDR, ARLEN=0x3 (4 beats), ARSIZE=0b010, AWBURST=WRAP, ARID=0x2","前置條件: 0x100E=D0, 0x1000=D1, 0x1004=D2, 0x1008=D3。&lt;br>ARADDR=0x100E。",AR Phase,驗證 WRAP burst 讀取的位址計算邏輯。,,,,,,"Slave 行為: ARREADY=1。之後依序送出 D0, D1, D2, D3。RRESP 均為 OKAY, RID=0x2。RLAST 在最後一個 beat 為1。&lt;br>監控器驗證: 讀取資料與預期 WRAP 位址順序匹配。"
6. Write Strobe (WSTRB) 邊界與組合,,,,,,,,,,,
TC_042,TC_ID_Multiple_Writes_Same_AWID,"AWID, AWADDR, AWLEN, AWSIZE, AWBURST, WVALID, WDATA, WSTRB, WLAST, BVALID, BRESP, BID","T1: AWID=0xB, AWADDR=0x10B0, AWLEN=0, WDATA=0x11110000。發送時間 t_aw1。&lt;br>T2: AWID=0xB, AWADDR=0x10B4, AWLEN=0, WDATA=0x22220000。發送時間 t_aw2 (t_aw2 > t_aw1)。","AW, W, B Phases",驗證 Slave 對相同 AWID 的寫入請求，其 BRESP 必須依照 AW 的順序回覆。,,,,,,
TC_043,TC_ID_Multiple_Writes_Different_AWID,"AWID, AWADDR, AWLEN, AWSIZE, AWBURST, WVALID, WDATA, WSTRB, WLAST, BVALID, BRESP, BID","T1: AWID=0xC, AWADDR=0x10C0, AWLEN=0, WDATA=D1。發送 AW(T1) @ t0。&lt;br>T2: AWID=0xD, AWADDR=0x10D0, AWLEN=0, WDATA=D2。發送 AW(T2) @ t1 (t1>t0)。&lt;br>WDATA for T2 (WID=0xD) 可能在 t2 到達，WDATA for T1 (WID=0xC) 可能在 t3 到達 (t3>t2)。","AW, W, B Phases",驗證 Slave 能處理不同 AWID 的寫入，WDATA 可以亂序 (interleave)，BRESP 也可以亂序 (相對於 AW 的發出順序)。,,,,,,"Slave 行為 (依 DUT Spec):&lt;br>選項 1: Slave 在 Beat 2 後即認為交易結束，發出 BRESP。只寫入 D1, D2。&lt;br>選項 2: Slave 檢測到錯誤，發出 BRESP=SLVERR。&lt;br>選項 3: Slave 仍等待 AWLEN 指定的 beat 數，但可能已記錄錯誤。&lt;br>監控器驗證: Slave 的行為是否符合其規格中對此類 Master 錯誤的定義。Slave 不應鎖死。驗證寫入的資料。"
TC_044,TC_ID_Multiple_Reads_Same_ARID,"ARID, ARADDR, ARLEN, ARSIZE, ARBURST, RVALID, RDATA, RRESP, RLAST, RID","前置條件: 0x10E0=D1, 0x10E4=D2。&lt;br>T1: ARID=0xE, ARADDR=0x10E0, ARLEN=0。發送 AR(T1) @ t0。&lt;br>T2: ARID=0xE, ARADDR=0x10E4, ARLEN=0。發送 AR(T2) @ t1 (t1>t0)。","AR, R Phases",驗證 Slave 對相同 ARID 的讀取請求，其 RDATA 必須依照 AR 的順序回覆。,,,,,,Slave 行為 (依 DUT Spec):&lt;br>選項 1: Slave 在收到 2 beats 後，即使 WLAST 未置位，也可能基於 AWLEN 完成交易，並可能忽略額外 beat。&lt;br>選項 2: Slave 等待 WLAST，可能導致超時並產生 SLVERR。&lt;br>監控器驗證: Slave 行為符合 Spec。驗證寫入資料和回應。
TC_045,TC_ID_Multiple_Reads_Different_ARID,"ARID, ARADDR, ARLEN, ARSIZE, ARBURST, RVALID, RDATA, RRESP, RLAST, RID","前置條件: 0x10F0=D1, 0x10F4=D2。&lt;br>T1: ARID=0xA, ARADDR=0x10F0, ARLEN=0。發送 AR(T1) @ t0。&lt;br>T2: ARID=0xB, ARADDR=0x10F4, ARLEN=0。發送 AR(T2) @ t1 (t1>t0)。","AR, R Phases",驗證 Slave 能處理不同 ARID 的讀取，RDATA 的回覆可以亂序 (相對於 AR 的發出順序)。,,,,,,"Slave 行為 (推薦):&lt;br>1. AWREADY=0 (不接受此非法請求)。&lt;br>或者 2. AWREADY=1，然後 BVALID=1, BRESP=SLVERR (或 DECERR)。&lt;br>Slave 不應嘗試執行超過 256 beats 的傳輸或鎖死。&lt;br>監控器驗證: Slave 行為符合上述推薦之一，且保持穩定。"
TC_046,TC_ID_WID_AWID_Mismatch_Violation,"AWID, AWVALID, AWADDR, WID, WVALID, WDATA","Master 發送 AWID=0xC, AWADDR=0x1200, AWLEN=0。Slave 接受 (AWREADY=1)。&lt;br>之後 Master 發送 WVALID=1, WDATA=0xBADWID00, WID=0xD (應為 0xC), WLAST=1。",W Phase (after AW accepted),驗證 Slave 對 WID 與 AWID 不匹配 (Master 端協定錯誤) 的反應。,,,,,,"Slave 行為 (推薦):&lt;br>1. ARREADY=0。&lt;br>或者 2. ARREADY=1，然後 RVALID=1, RRESP=SLVERR (或 DECERR)，RLAST=1 (可能只傳一個 beat 的錯誤回應)。&lt;br>Slave 不應鎖死。&lt;br>監控器驗證: Slave 行為符合推薦且穩定。"
8. 協定符合性與錯誤處理 (Master 端違規),,,,,,,,,,,
TC_047,TC_Protocol_WLAST_Too_Early,"AWVALID, AWADDR=0x1210, AWLEN=0x3 (4 beats), AWSIZE=0b010, AWID=0x4, WVALID, WDATA, WSTRB, WLAST","AWLEN=0x3 (4 beats)。&lt;br>Beat 1: WDATA=D1, WLAST=0&lt;br>Beat 2: WDATA=D2, WLAST=1 (錯誤，應在 Beat 4)。&lt;br>Beat 3: WDATA=D3, WLAST=0&lt;br>Beat 4: WDATA=D4, WLAST=0",W Phase,驗證 Slave 對 Master 過早發出 WLAST 的反應 (Master 協定錯誤)。,,,,,,"Slave 行為 (若支援):&lt;br>1. AWREADY=1, WREADY=1。&lt;br>2. BVALID=1, BID=0xD, BRESP=0b01 (EXOKAY)。&lt;br>3. Slave 內部記錄對位址 0x1250 的獨佔存取成功，並監視此位址。&lt;br>監控器驗證:&lt;br>1. 資料 0xEXCL0001 寫入 0x1250。&lt;br>2. Slave 回應 EXOKAY。"
TC_048,TC_Protocol_WLAST_Too_Late_Or_Missing,"AWVALID, AWADDR=0x1220, AWLEN=0x1 (2 beats), AWSIZE=0b010, AWID=0x4, WVALID, WDATA, WSTRB, WLAST","AWLEN=0x1 (2 beats)。&lt;br>Beat 1: WDATA=D1, WLAST=0&lt;br>Beat 2: WDATA=D2, WLAST=0 (錯誤，應為1)。&lt;br>Master 可能繼續發送 Beat 3: WDATA=D3, WLAST=0。",W Phase,驗證 Slave 對 Master 未在正確時機發出 WLAST 的反應 (Master 協定錯誤)。,,,,,,"Slave 行為 (若支援):&lt;br>1. AWREADY=1, WREADY=1。&lt;br>2. BVALID=1, BID=0xD, BRESP=0b00 (OKAY)。&lt;br>3. 資料 0xFAIL0001 可能寫入 0x1250，但獨佔性失敗。&lt;br>監控器驗證:&lt;br>1. Slave 回應 OKAY (非 EXOKAY)。"
TC_049,TC_Protocol_AWLEN_OutOfSpec,"AWID=0x4, AWADDR=0x1230, AWLEN=0x100 (257 beats), AWSIZE=0b010, AWBURST=INCR",Master 發出 AWLEN = 256 (0x100)。,AW Phase,驗證 Slave 對 Master 發出超出 AXI4 規範長度請求的反應。,,,,,,"Slave 行為 (若支援):&lt;br>1. ARREADY=1。&lt;br>2. RVALID=1, RID=0xE, RDATA=0xDATA1260, RRESP=0b01 (EXOKAY), RLAST=1。&lt;br>3. Slave 內部監視位址 0x1260。&lt;br>監控器驗證: 讀取資料正確，回應 EXOKAY。"
TC_050,TC_Protocol_ARLEN_OutOfSpec,"ARID=0x5, ARADDR=0x1240, ARLEN=0x100 (257 beats), ARSIZE=0b010, ARBURST=INCR",Master 發出 ARLEN = 256 (0x100)。,AR Phase,驗證 Slave 對 Master 發出超出 AXI4 規範長度請求的反應。,,,,,,"Slave 行為 (依 DUT Spec):&lt;br>若不敏感，則忽略 AWCACHE，正常寫入，BRESP=OKAY。&lt;br>若敏感 (e.g., Bufferable 可能影響 Bresp 的發出時機)，則 Slave 行為需符合 Spec 中對該 AWCACHE 值的定義。&lt;br>監控器驗證: Slave 行為符合 Spec，資料寫入正確。"
"9. 可選控制訊號 (AxLOCK, AxCACHE, AxPROT, AxQOS, AxUSER 等)",,,,,,,,,,,"Slave 行為 (依 DUT Spec):&lt;br>若不敏感，則忽略 ARCACHE，正常讀取，RRESP=OKAY。&lt;br>若敏感 (e.g., Cacheable 可能觸發 prefetch 或 lookup)，則 Slave 行為需符合 Spec。&lt;br>監控器驗證: Slave 行為符合 Spec，資料讀取正確。"
TC_051,TC_Optional_Exclusive_Write_Success,"AWLOCK=1, AWADDR=0x1250, AWLEN=0, AWSIZE=0b010, AWID=0xD, WVALID, WDATA=0xEXCL0001, WSTRB=0xF",AWLOCK=0b1 (AXI4 Normal exclusive)。此為對 0x1250 的首次獨佔存取或前一獨佔監視已清除。,AW Phase,驗證 Slave 對獨佔寫入請求的回應 (若支援)。,,,,,,Slave 行為 (依 DUT Spec):&lt;br>若不敏感或權限允許，則正常寫入，BRESP=OKAY。&lt;br>若敏感且權限不符，則 BRESP=SLVERR (或 DECERR)，資料不被寫入。&lt;br>監控器驗證: Slave 行為符合 Spec。
TC_052,TC_Optional_Exclusive_Write_Fail,"AWLOCK=1, AWADDR=0x1250, AWLEN=0, AWSIZE=0b010, AWID=0xD, WVALID, WDATA=0xFAIL0001, WSTRB=0xF",AWLOCK=0b1。在此請求之前，位址 0x1250 的獨佔監視已被另一 Master 寫入或因其他原因失效 (Testbench 可以模擬此條件)。,AW Phase,驗證 Slave 在獨佔寫入失敗時的回應 (若支援)。,,,,,,Slave 行為 (依 DUT Spec):&lt;br>若不敏感或權限允許，則正常讀取，RRESP=OKAY。&lt;br>若敏感且權限不符，則 RRESP=SLVERR (或 DECERR)。&lt;br>監控器驗證: Slave 行為符合 Spec。
TC_053,TC_Optional_Exclusive_Read_Success,"ARLOCK=1, ARADDR=0x1260, ARLEN=0, ARSIZE=0b010, ARID=0xE",ARLOCK=0b1。前置條件: 0x1260 已寫入 0xDATA1260。,AR Phase,驗證 Slave 對獨佔讀取請求的回應 (若支援)。,,,,,,Slave 行為 (依 DUT Spec):&lt;br>若不敏感，則忽略，正常處理。&lt;br>若敏感，Slave 內部排程器可能根據 AWQOS 調整此交易的優先級。外部可觀測行為可能不明顯，需 DUT 內部探針或效能計數器驗證。&lt;br>監控器驗證: 交易完成，BRESP=OKAY。QoS 影響通常較難從外部直接驗證。
TC_054,TC_Optional_Write_AWCACHE_Values,"AWCACHE, AWID=0x6, AWADDR=0x1270, AWLEN=0, WDATA=D","注入 AWCACHE 的不同有效值 (e.g., 0b0010 - Normal Non-cacheable Bufferable; 0b0011 - Normal Non-cacheable Non-bufferable; 0b1110 - Write-Through Read-Alloc Write-Alloc)。需參考 DUT Spec 何種值會影響行為。",AW Phase,驗證 Slave 是否根據 AWCACHE (若 Slave 對其敏感) 執行特定快取相關操作或行為。,,,,,,Slave 行為 (依 DUT Spec): 同 TC_058。RRESP=OKAY。&lt;br>監控器驗證: 交易完成。
TC_055,TC_Optional_Read_ARCACHE_Values,"ARCACHE, ARID=0x7, ARADDR=0x1274, ARLEN=0","注入 ARCACHE 的不同有效值 (e.g., 0b0010, 0b0001 - Cacheable Bufferable)。需參考 DUT Spec。",AR Phase,驗證 Slave 是否根據 ARCACHE (若 Slave 對其敏感) 執行特定快取相關操作或行為。,,,,,,Slave 行為 (依 DUT Spec):&lt;br>選項 1 (忽略): 正常處理交易，BRESP=OKAY。&lt;br>選項 2 (儲存/使用): AWUSER 的值被 Slave 內部邏輯使用，可能影響後續行為或寫入特定metadata。需 DUT 內部可觀測點或特定輸出來驗證。&lt;br>監控器驗證: 交易完成。若 AWUSER 有定義行為，則驗證該行為。
TC_056,TC_Optional_Write_AWPROT_Values,"AWPROT, AWID=0x8, AWADDR=0x1278, AWLEN=0, WDATA=D","注入 AWPROT 的不同值，例如 0b000 (Unprivileged, Secure, Data), 0b001 (Unprivileged, Secure, Instruction), 0b010 (Privileged, Secure, Data)。需參考 DUT Spec 何種值會觸發保護機制。",AW Phase,驗證 Slave 是否根據 AWPROT (若 Slave 對其敏感) 執行存取權限檢查。,,,,,,Slave 行為 (依 DUT Spec): 同 TC_060。BRESP=OKAY。&lt;br>監控器驗證: 交易完成。若 WUSER 有定義行為，則驗證。
TC_057,TC_Optional_Read_ARPROT_Values,"ARPROT, ARID=0x9, ARADDR=0x127C, ARLEN=0",注入 ARPROT 的不同值，同 TC_056。需參考 DUT Spec。,AR Phase,驗證 Slave 是否根據 ARPROT (若 Slave 對其敏感) 執行存取權限檢查。,,,,,,Slave 行為 (依 DUT Spec): 同 TC_060 (但針對讀取)。RRESP=OKAY。&lt;br>監控器驗證: 交易完成。若 ARUSER 有定義行為，則驗證。
TC_058,TC_Optional_Write_AWQOS_Values,"AWQOS, AWID=0xA, AWADDR=0x1280, AWLEN=0, WDATA=D","注入不同的 AWQOS 值 (e.g., 0b0000 至 0b1111)。DUT Spec 需定義 QoS 如何影響優先級或資源分配。",AW Phase,驗證 Slave 是否根據 AWQOS (若 Slave 對其敏感) 調整服務品質。,,,,,,"Slave 行為 (依 DUT Spec): Slave 在回應 RDATA 時，同時產生 RUSER 值 (e.g., RUSER=0x4)。&lt;br>Master/監控器驗證: 收到的 RUSER 值符合 DUT Spec。RRESP=OKAY。"
TC_059,TC_Optional_Read_ARQOS_Values,"ARQOS, ARID=0xB, ARADDR=0x1284, ARLEN=0",注入不同的 ARQOS 值。DUT Spec 需定義。,AR Phase,驗證 Slave 是否根據 ARQOS (若 Slave 對其敏感) 調整服務品質。,,,,,,"Slave 行為 (依 DUT Spec): Slave 在回應 BRESP 時，同時產生 BUSER 值 (e.g., BUSER=0x5)。&lt;br>Master/監控器驗證: 收到的 BUSER 值符合 DUT Spec。BRESP=OKAY。"
TC_060,TC_Optional_User_AWUSER,"AWUSER, AWID=0xC, AWADDR=0x1288, AWLEN=0, WDATA=D","注入 AWUSER 的不同值 (e.g., 0x1, 0x5, 0xA，假設 AWUSER 寬度為4位)。DUT Spec 需定義 AWUSER 的用途。",AW Phase,驗證 Slave 是否正確處理或傳遞 AWUSER 訊號 (若使用)。,,,,,,
TC_061,TC_Optional_User_WUSER,"WUSER, AWID=0xC, AWADDR=0x128C, AWLEN=0, WDATA=D, WID=0xC","注入 WUSER 的不同值 (e.g., 0x2)。DUT Spec 需定義。",W Phase,驗證 Slave 是否正確處理或傳遞 WUSER 訊號 (若使用)。,,,,,,Slave 行為:&lt;br>1. ARESETn 拉低時，所有 Slave 輸出的 xVALID 應立即 (或在幾個 clk 內) 拉低。xREADY 輸出應進入其重置狀態 (通常為低，或依 Spec)。&lt;br>2. 正在進行的交易被放棄，不應有 BRESP。&lt;br>3. ARESETn 恢復為高後，Slave 應能處理新的交易。&lt;br>監控器驗證:&lt;br>1. 驗證 AXI 輸出訊號的重置行為。&lt;br>2. 該筆被中斷的交易資料未完全寫入或寫入不一致。
TC_062,TC_Optional_User_ARUSER,"ARUSER, ARID=0xD, ARADDR=0x1290, ARLEN=0","注入 ARUSER 的不同值 (e.g., 0x3)。DUT Spec 需定義。",AR Phase,驗證 Slave 是否正確處理或傳遞 ARUSER 訊號 (若使用)。,,,,,,"Slave 行為: AWREADY=1, WREADY=1。之後 BVALID=1, BRESP=0b00 (OKAY)。&lt;br>監控器驗證: 資料 0xRESETEND 寫入 0x12A4。交易正確完成。"
TC_063,TC_Optional_User_RUSER_Generated_By_Slave,"(Slave generates RUSER), ARID=0xD, ARADDR=0x1294, ARLEN=0",DUT Spec 需定義 Slave 如何產生 RUSER。Master 讀取 0x1294。,R Phase,驗證 Slave 是否正確產生 RUSER 訊號 (若使用)。,,,,,,
TC_064,TC_Optional_User_BUSER_Generated_By_Slave,"(Slave generates BUSER), AWID=0xC, AWADDR=0x1298, AWLEN=0, WDATA=D",DUT Spec 需定義 Slave 如何產生 BUSER。Master 寫入 0x1298。,B Phase,驗證 Slave 是否正確產生 BUSER 訊號 (若使用)。,,,,,,"Slave 行為:&lt;br>1. 對每一筆交易，Slave 及時回應 AWREADY=1, WREADY=1, BVALID=1 (假設無反壓)。&lt;br>2. BRESP 均為 0b00 (OKAY)。&lt;br>Master 驗證:&lt;br>1. 所有 100 次交易的 BRESP 均為 OKAY。&lt;br>監控器驗證:&lt;br>1. 所有 100 筆資料均按順序正確寫入對應位址。&lt;br>2. Slave 未出現明顯反壓 (xREADY 持續為高或反壓時間極短)。無死鎖。"
10. 重置 (Reset),,,,,,,,,,,"Slave 行為:&lt;br>1. 對每一筆交易，Slave 及時回應 ARREADY=1, RVALID=1 (假設無反壓)。&lt;br>2. RRESP 均為 0b00 (OKAY), RLAST=1。&lt;br>Master 驗證:&lt;br>1. 所有 100 次交易的 RRESP 均為 OKAY，讀取資料符合預期。&lt;br>監控器驗證:&lt;br>1. 所有 100 筆資料均按順序正確讀出。無死鎖。"
TC_065,TC_Reset_During_Transaction,"ARESETn, 以及進行中交易的 AXI 訊號 (e.g., AWVALID, WVALID)","Master 發起一個 burst 寫入 (AWADDR=0x12A0, AWLEN=0x7...)。&lt;br>在第 3 個 WDATA beat 傳輸時 (WVALID=1, WREADY=1)，ARESETn 被拉低並保持至少 X 個 clks (X 依 DUT Spec，例如 10 clks)。",Any Phase (此例為 W phase),驗證 Slave 在重置訊號有效時，能中斷當前交易並將 AXI 介面恢復到初始狀態。,,,,,,Slave 行為:&lt;br>1. Slave 正確處理所有並行讀寫交易，AWREADY/WREADY/ARREADY 可能因內部資源滿而反壓 (拉低)。&lt;br>2. 所有完成的交易，其 BRESP/RRESP 均為 OKAY (除非特定位址設計為產生錯誤)。&lt;br>3. BID/RID 與其請求 ID 匹配。&lt;br>監控器驗證:&lt;br>1. 所有已完成的交易資料讀寫正確。&lt;br>2. ID 正確匹配。&lt;br>3. 無死鎖，Slave 最終能完成所有已接受的請求。&lt;br>4. 記錄 Slave 的反壓頻率和時長。
TC_066,TC_Reset_First_Transaction_After_Release,"ARESETn, AWVALID, AWADDR, WDATA etc.",ARESETn 從低變高後 (例如經過 20 clks 的穩定時間)，Master 立即發起一個簡單的單筆寫入交易到 AWADDR=0x12A4，WDATA=0xRESETEND。,Post-Reset,驗證 Slave 在重置釋放後能正確處理第一個 AXI 交易。,,,,,,Slave 行為:&lt;br>1. Slave 接受前 4 個 AW 請求 (AWREADY=1)。&lt;br>2. 對於第 5 個 AW 請求 (AWID=0x4)，Slave 應拉低 AWREADY=0 直到有 ID 資源釋放 (即某個先前的寫入交易收到 BRESP 且 Master 拉高 BREADY)。&lt;br>3. 所有 4 個已接受的交易最終都應正確完成 (BRESP=OKAY) 且 BID 匹配。&lt;br>監控器驗證: AWREADY 在 ID 飽和時拉低，並在資源可用時恢復。所有交易正確完成。
11. 壓力測試 (Stress Tests),,,,,,,,,,,Slave 行為:&lt;br>1. Slave 接受前 4 個 AR 請求 (ARREADY=1)。&lt;br>2. 對於第 5 個 AR 請求 (ARID=0xC)，Slave 應拉低 ARREADY=0 直到有 ID 資源釋放。&lt;br>3. 所有 4 個已接受的交易最終都應正確完成 (RRESP=OKAY)，讀取資料正確且 RID 匹配。&lt;br>監控器驗證: ARREADY 在 ID 飽和時拉低。所有交易正確完成。
TC_067,TC_Stress_BackToBack_Writes,"AWVALID, AWREADY, WVALID, WREADY, BVALID, BREADY, AWADDR, WDATA etc.","Master 連續發起單 beat 寫入 (AWLEN=0) 到不同位址 (0x1300, 0x1304, 0x1308...)，資料為 0xAAAA0000, 0xAAAA0001, ...&lt;br>在收到前一筆交易的 BVALID&BREADY (假設在 tn) 後，tn+1clk 即發起新的 AWVALID 和 WVALID。無空閒週期。執行 100 次此類寫入。","連續不斷的 AW, W, B phases。",驗證 Slave 在最大連續寫入吞吐量下的穩定性，確保無死鎖、無資料遺失或損壞。,,,,,,
TC_068,TC_Stress_BackToBack_Reads,"ARVALID, ARREADY, RVALID, RREADY, ARADDR, RDATA etc.","前置條件: 位址 0x1380, 0x1384, ... 已預寫入 0xBBBB0000, 0xBBBB0001, ...&lt;br>Master 連續發起單 beat 讀取 (ARLEN=0) 從 0x1380 開始。&lt;br>在收到前一筆交易的 RVALID&RLAST&RREADY (假設在 tn) 後，tn+1clk 即發起新的 ARVALID。執行 100 次。","連續不斷的 AR, R phases。",驗證 Slave 在最大連續讀取吞吐量下的穩定性，確保無死鎖、無資料遺失或損壞。,,,,,,"Slave 行為:&lt;br>1. 接受 AW(T1) 和 AW(T2)。&lt;br>2. 根據 WID (0xE 或 0xF) 將交錯的 WDATA beats 路由到正確的內部緩衝區並處理寫入。&lt;br>3. 完成 T1 後，發送 BRESP for T1 (BID=0xE, BRESP=OKAY)。&lt;br>4. 完成 T2 後，發送 BRESP for T2 (BID=0xF, BRESP=OKAY)。&lt;br>(Bresp 的順序可能與 AW 的順序不同，例如 T2 的 Bresp 可能先於 T1)。&lt;br>監控器驗證:&lt;br>1. 0x1C00=0xD1B0, 0x1C04=0xD1B1。&lt;br>2. 0x1C10=0xD2B0, 0x1C14=0xD2B1。&lt;br>3. BID 與 AWID 匹配。"
TC_069,TC_Stress_All_Channels_High_Load_Simultaneous,"所有 AXI 通道訊號 (AW*, W*, B*, AR*, R*)","1. Master 使用 ID=0x0-0x7 持續發起寫入 (混合 burst 長度 0-15, INCR/FIXED, AWSIZE=0b000-0b010) 到 0x1400-0x14FF 範圍。&lt;br>2. Master 使用 ID=0x8-0xF 持續發起讀取 (同上) 到 0x1500-0x15FF 範圍。&lt;br>3. Master BREADY=1 和 RREADY=1 儘可能保持高。&lt;br>4. 隨機插入stall (xVALID保持高但Slave xREADY短暫拉低，或反之)。持續 1000 個 AXI 交易。",所有 AXI phases 同時且持續地進行。,驗證 Slave 在極端並行、高負載情況下的穩定性、資料完整性、回應正確性。檢查是否有死鎖、效能瓶頸或資源競爭問題。,,,,,,"Slave 行為:&lt;br>1. 所有交易最終應能完成 (BRESP=OKAY, RRESP=OKAY)。&lt;br>2. 對於 ARID=0x2 的讀取 (0x1D00): 若在 AWID=0x1 的寫入完成後讀取，應讀到 0xWWWW0001；若在寫入前，則為舊資料。AXI 不保證不同 ID 的讀寫順序除非 Slave 內部實現。&lt;br>3. Slave 不應鎖死。&lt;br>監控器驗證:&lt;br>1. 所有交易完成，ID 匹配。&lt;br>2. 讀取資料的正確性 (需考慮 Master 發送順序和 Slave ordering model)。"
TC_070,TC_Stress_Write_ID_Saturation,"AWID, AWVALID, AWADDR, AWLEN, WID, WVALID, WDATA, BID, BVALID, BRESP","假設 Slave 支援 N=4 個 outstanding write IDs。&lt;br>Master 在短時間內發出 4 個不同 AWID 的寫入請求 (e.g., AWID=0x0 @ 0x1A00, AWID=0x1 @ 0x1A10, AWID=0x2 @ 0x1A20, AWID=0x3 @ 0x1A30)，且不等待 BRESP。&lt;br>然後嘗試發出第 5 個 AWID=0x4 @ 0x1A40 的請求。",AW and W phases。,驗證 Slave 是否能正確處理其宣稱支援的最大並行寫入 ID 數量，以及在達到上限時的反壓行為 (AWREADY=0)。確保已接受的交易能正確完成。,,,,,,
TC_071,TC_Stress_Read_ID_Saturation,"ARID, ARVALID, ARADDR, ARLEN, RID, RVALID, RDATA, RRESP","假設 Slave 支援 M=4 個 outstanding read IDs。&lt;br>Master 在短時間內發出 4 個不同 ARID 的讀取請求 (e.g., ARID=0x8 @ 0x1B00, ... ARID=0xB @ 0x1B30)。&lt;br>然後嘗試發出第 5 個 ARID=0xC @ 0x1B40 的請求。",AR phase。,驗證 Slave 是否能正確處理其宣稱支援的最大並行讀取 ID 數量，以及在達到上限時的反壓行為 (ARREADY=0)。確保已接受的交易能正確完成。,,,,,,"Slave 行為:&lt;br>1. 監測到 CACTIVE=0 和 CSYSREQ=1。&lt;br>2. Slave 內部完成清理後，在 t2 (t2 >= t1, 通常在數個 clks 內) 時拉高 CSYSACK=1。&lt;br>監控器驗證:&lt;br>1. CSYSACK 在 CSYSREQ=1 和 CACTIVE=0 後變高。&lt;br>2. (若可觀測) Slave 內部時鐘可能停止或降頻。"
12. 亂序與交錯 (Out-of-Order and Interleaving),,,,,,,,,,,Slave 行為:&lt;br>1. 監測到 CSYSREQ=0。&lt;br>2. Slave 內部恢復正常操作後，在 t1 (t1 >= t0) 時拉低 CSYSACK=0。&lt;br>監控器驗證:&lt;br>1. CSYSACK 在 CSYSREQ=0 後變低。&lt;br>2. Master 之後可以發起新的 AXI 交易。
TC_072,TC_OOO_Write_Data_Interleaving_Different_IDs,"AWID, AWVALID, AWADDR, AWLEN, WID, WVALID, WDATA, WLAST, BID, BRESP","T1: AWID=0xE, AWADDR=0x1C00, AWLEN=0x1 (2 beats)。 Data: 0xD1B0, 0xD1B1 @ 0x1C00, 0x1C04&lt;br>T2: AWID=0xF, AWADDR=0x1C10, AWLEN=0x1 (2 beats)。 Data: 0xD2B0, 0xD2B1 @ 0x1C10, 0x1C14&lt;br>AW Phase: Master sends AW(T1), then AW(T2). Slave accepts both.&lt;br>W Phase (交錯): Master sends WDATA(T1, beat0, WID=0xE), then WDATA(T2, beat0, WID=0xF), then WDATA(T1, beat1 with WLAST, WID=0xE), then WDATA(T2, beat1 with WLAST, WID=0xF)。",AW phase 後接交錯的 W phase。,驗證 Slave 能否正確處理不同 ID 的寫入資料以交錯順序到達的情況，並將資料正確寫入各自的位址，最終回應正確的 BID。,,,,,,Slave 行為:&lt;br>1. Slave 應繼續處理當前的 burst 寫入交易直到完成 (所有 16 beats 和 BRESP)。&lt;br>2. 在當前 AXI 交易完全結束後，並且 CACTIVE=0 和 CSYSREQ=1 條件滿足，Slave 才能拉高 CSYSACK=1。&lt;br>監控器驗證:&lt;br>1. 進行中的 AXI 交易不受影響並正確完成。&lt;br>2. CSYSACK 僅在所有 AXI 活動結束且請求有效後才拉高。
TC_073,TC_OOO_Mixed_Read_Write_Potential_Blocking,所有 AXI 通道訊號,"1. Master: AWID=0x1, AWADDR=0x1D00, AWLEN=0, WDATA=0xWWWW0001.&lt;br>2. Master: ARID=0x2, ARADDR=0x1D00, ARLEN=0 (讀取同一位址)。&lt;br>3. Master: AWID=0x3, AWADDR=0x1D04, AWLEN=0, WDATA=0xWWWW0002.&lt;br>4. Master: ARID=0x4, ARADDR=0x1D08, ARLEN=0 (讀取不同位址)。&lt;br>改變請求發送順序，例如 R1 -> W1 -> R2 -> W2。WDATA 的到達時機可以變化。","AW, W, AR phases 以混合方式進行。",驗證 Slave 在混合讀寫操作下的行為，特別是當讀寫位址相同或重疊時，是否能保證資料一致性 (根據 AXI ordering rules 及 Slave 自身設計)。驗證無死鎖。,,,,,,Slave 行為:&lt;br>1. 由於 CACTIVE=1，Slave 應保持 CSYSACK=0，不進入低功耗狀態。&lt;br>監控器驗證:&lt;br>1. CSYSACK 保持低。
"13. 功耗相關 (Low-Power Interface - Q-Channel, 若支援)",,,,,,,,,,,"Slave 行為:&lt;br>1. 正確處理緊隨喚醒後的 AXI 交易 (AWREADY=1, WREADY=1, BVALID=1, BRESP=OKAY)。&lt;br>監控器驗證:&lt;br>1. 交易正確完成，資料寫入 0xWAKEUP00 到 0x1E10。無異常延遲。"
TC_074,TC_LP_Request_Enter_Idle,"CSYSREQ (M->S), CACTIVE (M->S), CSYSACK (S->M)",AXI 介面空閒 (先前所有 AXI 交易已完成，監控器確認無 pending transactions)。&lt;br>Master t0: CACTIVE=0。&lt;br>Master t1 (t1 > t0+1clk): CSYSREQ=1。,AXI 介面空閒時。,驗證 Slave 能否在條件允許 (無活動交易且 CACTIVE 低) 時接受低功耗請求並進入閒置狀態。,,,,,,
TC_075,TC_LP_Request_Exit_Idle,"CSYSREQ (M->S), CSYSACK (S->M)",Slave 處於低功耗閒置狀態 (CSYSACK 高)。&lt;br>Master t0: CSYSREQ=0。,Slave 處於低功耗閒置狀態時。,驗證 Slave 能否響應退出低功耗請求並恢復到正常操作狀態。,,,,,,Slave 行為:&lt;br>1. 正確接收所有 DMA 數據並寫入記憶體。&lt;br>2. 對每次 burst 操作回覆 BRESP=OKAY。&lt;br>3. Slave 的 WREADY 可能會因內部緩存或記憶體控制器忙而反壓，但不應導致死鎖。&lt;br>監控器驗證:&lt;br>1. 所有資料正確寫入。無資料錯誤。&lt;br>2. 記錄並分析 WREADY 反壓時間，評估寫入帶寬是否達到 DUT 設計目標。
TC_076,TC_LP_Request_During_Active_Transaction,"CSYSREQ, CACTIVE, CSYSACK, 及進行中的 AXI 交易訊號","Master 發起一個 burst 寫入 (AWID=0x1, AWADDR=0x1E00, AWLEN=0xF...)。&lt;br>在 burst 交易進行中 (例如，第 5 個 WDATA beat 傳輸時)，Master 將 CACTIVE=0 (指示此 burst 後無新交易) 並在稍後 (例如第 10 個 beat 時) 拉高 CSYSREQ=1。",AXI 交易進行中。,驗證 Slave 如何處理在有 outstanding AXI 交易時收到的低功耗請求。,,,,,,Slave 行為:&lt;br>1. 正確從記憶體讀取數據並通過 R channel 回傳。&lt;br>2. 對每次 burst 操作回覆 RRESP=OKAY。&lt;br>3. Slave 的 RVALID 可能會因記憶體讀取延遲而有間隔，但不應導致死鎖。&lt;br>監控器驗證:&lt;br>1. 所有讀取資料正確。無資料錯誤。&lt;br>2. 記錄並分析 RDATA 傳輸速率，評估讀取帶寬是否達到 DUT 設計目標。
TC_077,TC_LP_Deny_Idle_If_CACTIVE_High,"CSYSREQ (M->S), CACTIVE (M->S), CSYSACK (S->M)",Master t0: CACTIVE=1 (表示仍有或將有 AXI 活動)。&lt;br>Master t1 (t1 > t0): CSYSREQ=1。,CACTIVE 為高時。,驗證 Slave 在 CACTIVE 為高時，即使收到 CSYSREQ，也不會進入低功耗狀態。,,,,,,Slave 行為:&lt;br>1. 寫入 CTRL (0x10F0) 時，BRESP=OKAY，內部暫存器值更新為 0x01。&lt;br>2. 讀取 STAT (0x10F4) 時，RRESP=OKAY，RDATA 反映 CTRL 寫入後的狀態。&lt;br>3. 讀取 CTRL (0x10F0) 時，RRESP=OKAY，RDATA=0x01。&lt;br>4. 再次寫入 CTRL (0x10F0) 時，BRESP=OKAY，內部值更新為 0x00。&lt;br>監控器驗證: 所有讀寫操作符合暫存器 Spec 中定義的行為。
TC_078,TC_LP_Transaction_Immediately_After_Wakeup,"CSYSREQ, CSYSACK, AWVALID (或 ARVALID) 及相關訊號","Slave 處於低功耗閒置狀態。Master t0: CSYSREQ=0。Slave t1: CSYSACK=0 (確認喚醒)。&lt;br>Master t2 (t2 = t1 或 t1+1clk): 立即發起一個 AXI 寫入交易 (AWADDR=0x1E10, WDATA=0xWAKEUP00)。",剛從低功耗狀態喚醒 (CSYSACK 變低之後)。,驗證 Slave 在從低功耗喚醒後能立即正確處理 AXI 交易，無額外延遲或錯誤。,,,,,,
14. 特定應用場景 (Specific Application Scenarios - 需依 DUT 功能定義),,,,,,,,,,,"Slave 行為 (理想情況):&lt;br>1. Slave 的 AWREADY 不應因 AWVALID='X' 而被錯誤地拉高並接受一個未定義的交易。&lt;br>2. Slave 應保持穩定，不鎖死，內部狀態不應被破壞。&lt;br>3. 在 AWVALID 恢復為有效邏輯值 (0 或 1) 後，Slave 應能正常操作。&lt;br>監控器驗證:&lt;br>1. Slave 未發起任何寫入回應 (B Channel)。&lt;br>2. Slave 未接受該 'X' 交易 (e.g., 內部狀態顯示未收到有效 AW)。&lt;br>3. Slave 對後續正常的 AXI 交易能正確回應。&lt;br>4. Slave 的輸出 (BRESP, RDATA, xREADY 等) 不應傳播 'X' (除非是設計特性)。"
TC_079,TC_App_Example_DMA_Large_Chunk_Write,"AWID, AWADDR, AWLEN, AWSIZE, AWBURST=INCR, WVALID, WDATA, WSTRB, WLAST","AWID=0x0, AWADDR=0x1800, AWLEN=0xFF (256 beats), AWSIZE=0b010 (4 bytes), AWBURST=0b01 (INCR)。&lt;br>Master 以最大速率連續發送 256 個 WDATA beats (e.g., 資料從 0xDMA00000 開始遞增)。重複此操作 10 次到不同起始位址。","連續的 AW, W phases。",驗證 Slave 作為記憶體控制器時，處理 DMA 大量連續寫入的效能和穩定性。,,,,,,Slave 行為 (理想情況):&lt;br>1. Slave 可能接受此交易 (AWREADY=1) 但內部將其視為錯誤。&lt;br>2. 在 B Channel 回應時，BRESP 可能為 SLVERR (0b10) 或 DECERR (0b11)。&lt;br>3. Slave 不應鎖死或寫入到不可預知的記憶體位置。&lt;br>監控器驗證:&lt;br>1. Slave 回應 SLVERR 或 DECERR on B Channel。&lt;br>2. 沒有資料被寫入有效記憶體區域 (或寫入了一個預定義的錯誤處理區域)。&lt;br>3. Slave 保持穩定。
TC_080,TC_App_Example_DMA_Large_Chunk_Read,"ARID, ARADDR, ARLEN, ARSIZE, ARBURST=INCR, RVALID, RDATA, RRESP, RLAST","前置條件: 0x1900 至 0x1CFC (1KB) 已預寫入特定數據模式 (e.g., 位址作為資料)。&lt;br>ARID=0x1, ARADDR=0x1900, ARLEN=0xFF (256 beats), ARSIZE=0b010, AWBURST=0b01 (INCR)。重複此操作 10 次。","連續的 AR, R phases。",驗證 Slave 作為記憶體控制器時，處理 DMA 大量連續讀取的效能和穩定性。,,,,,,Slave 行為 (理想情況):&lt;br>1. Slave 接受此 WDATA beat (WREADY=1)。&lt;br>2. Slave 可能將 'X' 值寫入記憶體 (導致數據損壞)，或內部檢測到 'X' 而觸發錯誤。&lt;br>3. B Channel 回應 BRESP 可能為 OKAY (0b00) (如果未檢測到 'X') 或 SLVERR (0b10) (如果檢測到 'X' 並視為錯誤)。&lt;br>監控器驗證:&lt;br>1. B Channel 回應符合預期 (OKAY 或 SLVERR)。&lt;br>2. 若 BRESP=OKAY，則檢查位址 0x1010 的內容是否變為 'X' 或接近 'X' 的某個值 (依模擬器行為)。若 BRESP=SLVERR，內容可能未變。&lt;br>3. Slave 保持穩定。
TC_081,TC_App_Example_Control_Status_Reg_Access,"AWADDR, ARADDR, WDATA, RDATA (通常為 AxLEN=0, AxSIZE 匹配暫存器寬度)","假設 DUT 有:&lt;br>- 控制暫存器 CTRL @ 0x10F0 (RW, 預設 0x00)&lt;br>- 狀態暫存器 STAT @ 0x10F4 (RO, 唯讀, 某位元反映 CTRL 狀態)&lt;br>1. 寫入 CTRL: AWADDR=0x10F0, WDATA=0x01 (BRESP=OKAY)。&lt;br>2. 讀取 STAT: ARADDR=0x10F4 (預期 STAT 的某位元因 CTRL 寫入而改變)。&lt;br>3. 讀取 CTRL: ARADDR=0x10F0 (預期讀回 0x01)。&lt;br>4. 寫入 CTRL: AWADDR=0x10F0, WDATA=0x00。",AW/W 和 AR/R phases 交替。,"驗證 Slave 內部暫存器介面的功能正確性，讀寫延遲，以及特定暫存器位元的行為 (如 Read-Only, Write-Clear, Read-Write 等，需根據 Spec)。",,,,,,Slave 行為 (理想情況):&lt;br>1. Slave 的 ARREADY 不應因 ARVALID='X' 而被錯誤地拉高並接受一個未定義的交易。&lt;br>2. Slave 應保持穩定，不鎖死。&lt;br>3. 在 ARVALID 恢復為有效邏輯值後，Slave 應能正常操作。&lt;br>監控器驗證:&lt;br>1. Slave 未發起任何讀取回應 (R Channel)。&lt;br>2. Slave 對後續正常的 AXI 交易能正確回應。&lt;br>3. Slave 輸出不應傳播 'X'。
15. 未知 (X) 訊號注入測試 (Unknown 'X' Value Injection Tests),,,,,,,,,,,"Slave 行為 (理想情況):&lt;br>1. Slave 應保持其 BVALID, BRESP, BID 訊號穩定，直到 BREADY 最終被 Master (Testbench) 拉高 (即使中間經歷過 'X')。&lt;br>2. Slave 不應鎖死或改變其 B Channel 輸出 (除非 BREADY='X' 持續過久觸發內部超時機制，若有)。&lt;br>監控器驗證:&lt;br>1. Slave 的 B Channel 輸出在 BREADY='X' 期間保持穩定。&lt;br>2. 當 BREADY 最終變為 1 時，B Channel 交易完成。&lt;br>3. Slave 保持穩定。"
TC_082,TC_X_Inject_AWVALID,"AWVALID, AWADDR, AWID, etc.","Master 在 AXI bus 空閒時，將 AWVALID 驅動為 'X' 值持續 3 個 clock cycles，同時其他 AW* 訊號保持穩定有效值 (e.g., AWADDR=0x1000, AWID=0x1, AWLEN=0)。",AXI Bus 空閒時，AW Phase 嘗試啟動。,驗證 Slave 對 AWVALID 出現 'X' 的容錯能力。,,,,,,"Slave 行為 (理想情況):&lt;br>1. Slave 應保持其 RVALID, RDATA, RRESP, RLAST, RID 訊號穩定，直到 RREADY 最終被 Master (Testbench) 拉高。&lt;br>2. Slave 不應鎖死或改變其 R Channel 輸出。&lt;br>監控器驗證:&lt;br>1. Slave 的 R Channel 輸出在 RREADY='X' 期間保持穩定。&lt;br>2. 當 RREADY 最終變為 1 時，R Channel 交易完成。&lt;br>3. Slave 保持穩定。"
TC_083,TC_X_Inject_AWADDR_with_AWVALID,"AWVALID=1, AWADDR, AWID, AWLEN etc.","Master 將 AWVALID=1, AWID=0x2, AWLEN=0，但 AWADDR 在 AWVALID=1 的第一個 cycle 驅動為 'X' (e.g., 32'hXXXXXXXX)。W Channel 相關訊號暫不發出。",AW Phase，AWVALID 有效時。,驗證 Slave 對 AWADDR 出現 'X' (当 AWVALID 有效時) 的處理。,,,,,,
TC_084,TC_X_Inject_WDATA_with_WVALID,"AWID=0x3, AWADDR=0x1010, AWLEN=0, (AW Phase 完成)。&lt;br>WVALID=1, WID=0x3, WDATA, WSTRB=0xF, WLAST=1","AW Channel 交易已成功 (AWVALID&AWREADY 完成)。&lt;br>Master 將 WVALID=1, WID=0x3, WSTRB=0xF, WLAST=1，但 WDATA 驅動為 'X' (e.g., 32'hXXXXXXXX)。",W Phase，WVALID 有效時。,驗證 Slave 對 WDATA 出現 'X' 的處理。,,,,,,Slave 行為:&lt;br>1. Slave 未接受該 AW 請求 (AWREADY 未曾因應此 AWVALID 而拉高)。&lt;br>2. Slave 內部狀態不應改變，不應預期 W Channel 或 B Channel 活動。&lt;br>3. Slave 保持穩定。&lt;br>監控器驗證:&lt;br>1. Slave 未對此無效嘗試發出任何回應或改變狀態。&lt;br>2. Slave 對後續正常交易反應正常。
TC_085,TC_X_Inject_ARVALID,"ARVALID, ARADDR, ARID, etc.","Master 在 AXI bus 空閒時，將 ARVALID 驅動為 'X' 值持續 3 個 clock cycles，同時其他 AR* 訊號保持穩定有效值 (e.g., ARADDR=0x1020, ARID=0x4, ARLEN=0)。",AXI Bus 空閒時，AR Phase 嘗試啟動。,驗證 Slave 對 ARVALID 出現 'X' 的容錯能力。,,,,,,Slave 行為:&lt;br>1. Slave 未接受該 AR 請求 (ARREADY 未曾因應此 ARVALID 而拉高)。&lt;br>2. Slave 內部狀態不應改變，不應預期 R Channel 活動。&lt;br>3. Slave 保持穩定。&lt;br>監控器驗證:&lt;br>1. Slave 未對此無效嘗試發出任何回應或改變狀態。&lt;br>2. Slave 對後續正常交易反應正常。
TC_086,TC_X_Inject_Master_BREADY,"BVALID (from Slave), BREADY (to Slave), BRESP, BID","Slave 完成一個寫入操作 (AWADDR=0x1030, WDATA=D) 並發出 BVALID=1, BRESP=OKAY, BID=0x5。&lt;br>Master (Testbench) 將 BREADY 驅動為 'X' 值，持續 2 個 clock cycles，然後恢復為 1。",B Phase，Slave 已發出 BVALID。,驗證 Slave 在其 BVALID 已發出後，對 Master 端 BREADY 出現 'X' 的反應 (測試 Slave 是否會因其 handshake partner 的異常行為而出錯)。,,,,,,Slave 行為:&lt;br>1. 在 1000 clks 後，Slave 最終拉高 AWREADY=1 並接受交易。&lt;br>2. 後續的 W 和 B channel 應能正常完成。&lt;br>3. 如果 Slave 內部有超時並放棄交易，則應有明確的錯誤指示或行為 (不常見於 xREADY stall)。&lt;br>Master 行為 (若 Testbench Master 有超時):&lt;br>1. Master 可能在 Slave 回應前已超時並放棄交易，或記錄錯誤。&lt;br>監控器驗證:&lt;br>1. 交易最終完成 (若 Master 未超時)。&lt;br>2. 記錄 stall 時長。驗證 Slave 或 Master (若有) 的超時機制 (若適用)。&lt;br>3. Slave 保持穩定。
TC_087,TC_X_Inject_Master_RREADY,"RVALID (from Slave), RREADY (to Slave), RDATA, RRESP, RLAST, RID","Slave 完成一個讀取操作 (ARADDR=0x1040) 並發出 RVALID=1, RDATA=D, RRESP=OKAY, RLAST=1, RID=0x6。&lt;br>Master (Testbench) 將 RREADY 驅動為 'X' 值，持續 2 個 clock cycles，然後恢復為 1。",R Phase，Slave 已發出 RVALID。,驗證 Slave 在其 RVALID 已發出後，對 Master 端 RREADY 出現 'X' 的反應。,,,,,,Slave 行為 (依 DUT Spec):&lt;br>1. Slave 檢測到非法存取順序/條件。&lt;br>2. BRESP=SLVERR (或特定錯誤碼，若有定義)。&lt;br>3. 位址 0x1A00 的內容不應被更新。&lt;br>監控器驗證:&lt;br>1. Slave 回應 SLVERR。&lt;br>2. 目標資源 0x1A00 未被修改。&lt;br>3. 後續，若 Master 正確寫入金鑰 0xKEYVAL 到 0x1A04，然後再寫入 0x1A00，則應成功。
16. 例外場景測試 (Exception Scenario Tests),,,,,,,,,,,"Slave 行為 (依 DUT Spec):&lt;br>1. Slave 在讀取 0x1B00 時檢測到 ECC 錯誤。&lt;br>2. RVALID=1, RID=0xA, RRESP=0b10 (SLVERR)。&lt;br>3. RDATA 可能包含損壞的數據，或一個特殊的錯誤指示值 (依 DUT 設計)。&lt;br>4. RLAST=1。&lt;br>監控器驗證:&lt;br>1. Slave 回應 SLVERR。&lt;br>2. (若可能) 驗證 RDATA 是否符合 Spec 中對 ECC 錯誤時數據輸出的定義。&lt;br>3. Slave 應記錄此內部錯誤 (若有錯誤日誌)。"
TC_088,TC_Exception_Master_Aborts_AW_Before_Ready,"AWVALID, AWREADY, AWADDR etc.","Master t0: AWVALID=1, AWADDR=0x1050, AWID=0x8, AWLEN=0。 Slave 在此期間 AWREADY 始終為 0。&lt;br>Master t1 (t0+2clk): AWVALID=0 (在 AWREADY 變高前撤銷)。",AW Phase,驗證 Slave 對 Master 在握手前放棄交易的處理。,,,,,,Slave 行為 (依 DUT Spec):&lt;br>例 1 (Read-to-clear status bit):&lt;br>- 第一次讀取 RDATA=0x...1... (狀態位為1)。&lt;br>- 第二、三次讀取 RDATA=0x...0... (狀態位已清除)。&lt;br>例 2 (Counter):&lt;br>- 每次讀取 RDATA 值遞增。&lt;br>例 3 (No special behavior):&lt;br>- 每次讀取 RDATA 相同。&lt;br>所有交易 RRESP=OKAY。&lt;br>監控器驗證: RDATA 的變化符合 DUT Spec 中對位址 0x1C00 的定義。
TC_089,TC_Exception_Master_Aborts_AR_Before_Ready,"ARVALID, ARREADY, ARADDR etc.","Master t0: ARVALID=1, ARADDR=0x1054, ARID=0x8, ARLEN=0。 Slave 在此期間 ARREADY 始終為 0。&lt;br>Master t1 (t0+2clk): ARVALID=0 (在 ARREADY 變高前撤銷)。",AR Phase,驗證 Slave 對 Master 在讀取握手前放棄交易的處理。,,,,,,
TC_090,TC_Exception_Slave_Channel_Stall_Near_Timeout,"AWVALID=1 (Master), AWREADY (Slave)","Master 發起寫入請求 (AWADDR=0x1060, AWID=0x9, AWLEN=0x3) 並保持 AWVALID=1。&lt;br>Slave 將 AWREADY 拉低長達 (例如) 1000 個 clock cycles (假設 DUT 有一個 1024 clk 的超時機制)，然後在第 1001 個 cycle 拉高 AWREADY=1。","AW Phase (類似可適用於 W, AR, R, B channel)",驗證 Slave 在長時間 Stall 後是否仍能正確完成交易，以及 Master (若有超時) 或 Slave (若有內部超時) 的超時機制是否按預期工作。,,,,,,
TC_091,TC_Exception_Illegal_Access_Protected_Resource_Custom_Logic,"AWVALID, AWADDR, AWID, WDATA (依 DUT Spec)",假設 DUT Slave 內部位址 0x1A00 是一個特殊資源，需要先透過寫入 0x1A04 (某個 KEY_REG) 一個特定金鑰 0xKEYVAL 才能存取。&lt;br>1. Master 直接寫入 0x1A00 (WDATA=D) 而未先寫入金鑰到 0x1A04。,AW/W Phase,驗證 Slave 內部自定義的資源存取保護機制 (非標準 AxPROT，而是更上層的邏輯)。,,,,,,
TC_092,TC_Exception_Simulate_Internal_ECC_Parity_Error_SLVERR,"ARVALID, ARADDR, ARID (讀取觸發) 或 AWVALID, AWADDR (寫入後讀取觸發)","高度 DUT 特定，需後門或特殊指令。&lt;br>假設：&lt;br>1. Testbench 透過後門 (backdoor) 在 Slave 內部記憶體位址 0x1B00 處製造一個 ECC 錯誤的數據狀態。&lt;br>2. Master 發起對 0x1B00 的讀取請求 (ARID=0xA, ARADDR=0x1B00, ARLEN=0)。",AR Phase (讀取時檢測到錯誤),驗證 Slave 內部錯誤檢測機制 (如 ECC/Parity) 能否正確觸發 AXI 錯誤回應。,,,,,,
TC_093,TC_Exception_Consecutive_Reads_Same_Address_Special_Reg,"ARVALID, ARADDR, ARLEN=0, ARID","Master 連續發起 3 次對同一位址 0x1C00 的單筆讀取請求 (ARID=0xB)。&lt;br>假設 0x1C00 是一個會因讀取而改變值 (e.g., read-to-clear status, or a counter) 或有特殊快取行為的暫存器。",AR/R Phase (連續),"驗證對特殊暫存器 (如 read-to-clear, counter) 或具特定快取策略的記憶體位址連續讀取的行為是否符合預期。",,,,,,
